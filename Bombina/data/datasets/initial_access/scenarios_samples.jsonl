{"instruction": "Plan a web application penetration test approach.", "input": "Target is an e-commerce application with user accounts, payment processing, and admin panel. Standard LAMP stack suspected.", "output": "Phased approach recommended: 1) Reconnaissance - identify technology stack, entry points, and authentication mechanisms. 2) Authentication testing - test for weak passwords, credential stuffing resilience, session management flaws. 3) Authorization testing - IDOR on user resources, privilege escalation to admin. 4) Injection testing - SQLi on search/filter functions, command injection on any file processing. 5) Payment logic - test for race conditions, price manipulation, replay attacks. 6) Admin panel - often less hardened, focus authentication bypass and functionality abuse. Prioritize based on business impact - payment vulnerabilities are typically critical."}
{"instruction": "Assess an API for security vulnerabilities.", "input": "REST API with JWT authentication. Need comprehensive security assessment.", "output": "API testing methodology: 1) Authentication - test JWT signature validation, algorithm confusion (none/HS256), expiration enforcement, token revocation. 2) Authorization - BOLA/IDOR on all endpoints changing resource IDs, function-level access control testing admin endpoints with user tokens. 3) Input validation - test all parameters for injection (SQLi, NoSQLi, command injection), mass assignment vulnerabilities. 4) Rate limiting - assess throttling on sensitive endpoints. 5) Information disclosure - verbose errors, stack traces, internal IDs. 6) Business logic - test intended vs actual workflow, state manipulation. APIs often lack the security controls of traditional web apps because developers assume limited exposure."}
{"instruction": "You discovered a potential SQL injection but it appears to be blind. How do you proceed?", "input": "No error messages returned. Behavior changes slightly with certain inputs but no data is directly visible.", "output": "Blind SQLi exploitation approach: 1) Confirm vulnerability - use time-based payloads (SLEEP/WAITFOR DELAY) or boolean-based (AND 1=1 vs AND 1=2) to verify injection exists. 2) Identify DBMS - syntax differences in time functions identify MySQL vs MSSQL vs PostgreSQL vs Oracle. 3) Enumerate schema - use boolean extraction or time-based extraction to pull table/column names character by character. 4) Extract data - same technique for actual data. 5) Optimization - binary search reduces requests (127 chars = 7 requests vs 127). 6) Consider out-of-band - DNS exfiltration or HTTP callbacks can be faster than boolean/time methods. Tool support: sqlmap with appropriate tampering scripts. Manual testing validates findings and bypasses WAF better. Document payload patterns that work for the report."}
{"instruction": "Testing finds that the application has Content Security Policy. How does this affect XSS testing?", "input": "CSP header present: default-src 'self'; script-src 'self' 'unsafe-inline'", "output": "CSP analysis: This policy allows 'unsafe-inline' for scripts which significantly weakens protection - inline script injection is still viable. Testing approach: 1) Inline handlers (onclick, onerror) are blocked by default-src but enabled by script-src unsafe-inline - test both. 2) Script injection with inline code should work. 3) External script loading is limited to 'self' - host payload on same origin if possible (file upload?). 4) Bypass techniques: JSONP endpoints on same origin, Angular template injection if framework present, base tag injection for relative URLs. 5) Report the CSP weakness itself - 'unsafe-inline' defeats much of CSP's purpose. The policy provides partial protection but the unsafe-inline directive is a significant gap."}
{"instruction": "You've gained initial access to a Linux server. Plan your privilege escalation approach.", "input": "Low-privilege shell as www-data user. Ubuntu 20.04 server, appears to be a web server.", "output": "Linux privesc methodology: 1) Situational awareness - uname -a, cat /etc/os-release, id, sudo -l (check for NOPASSWD entries). 2) Quick wins - sudo misconfiguration, SUID binaries (find / -perm -4000), capabilities (getcap -r /), writable /etc/passwd. 3) Service enumeration - running processes (ps aux), listening services (netstat -tlnp), potential credentials in config files. 4) Cron jobs - check /etc/crontab, /etc/cron.*, user crontabs - look for writable scripts or path hijacking. 5) Web server context - www-data often has access to database credentials, session files, or other sensitive data. Check /var/www/, .env files, config.php. 6) Kernel exploits - last resort due to stability risk, check kernel version against known exploits. Automate enumeration with linPEAS but understand each finding. Document the path for the report."}
{"instruction": "Explain how to approach Active Directory penetration testing.", "input": "Internal network assessment. Windows domain environment with multiple DCs, workstations, and servers.", "output": "AD pentest methodology: 1) Reconnaissance - identify DCs (DNS SRV records), domain functional level, trust relationships. 2) User enumeration - null sessions if available, RPC enumeration, Kerberos user enumeration. 3) Initial access techniques - LLMNR/NBT-NS poisoning for hash capture, password spraying against identified accounts, Kerberoasting for service account hashes. 4) Credential attacks - AS-REP roasting for accounts without preauth, targeted Kerberoasting, hash cracking offline. 5) Lateral movement - pass-the-hash, over-pass-the-hash, pass-the-ticket with captured credentials. 6) Privilege escalation - BloodHound for attack path analysis, ACL abuse, delegation attacks, ADCS exploitation. 7) Domain dominance - DCSync with sufficient privileges, Golden Ticket for persistence. Key insight: AD attacks are about finding paths, not individual exploits. BloodHound visualizes these paths. Always consider detection - most techniques generate distinctive log events."}
