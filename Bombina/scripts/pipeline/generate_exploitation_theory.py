#!/usr/bin/env python3
"""
Bombina Advanced Exploitation Theory Dataset
Teaches WHY vulnerabilities exist and HOW to find new ones
Focus: Root causes, exploitation mechanics, vulnerability patterns
"""

import json
import hashlib
import random
from pathlib import Path

output_dir = Path(__file__).parent.parent / "data" / "deep_knowledge"
output_dir.mkdir(parents=True, exist_ok=True)

seen_hashes = set()
all_samples = []

def add_sample(instruction, input_text, output, category="theory"):
    content = f"{instruction}|{input_text}"
    h = hashlib.md5(content.encode()).hexdigest()
    if h not in seen_hashes:
        seen_hashes.add(h)
        all_samples.append({
            "instruction": instruction, 
            "input": input_text, 
            "output": output,
            "category": category
        })
        return True
    return False

print("="*70)
print("üéØ GENERATING EXPLOITATION THEORY DATASET")
print("="*70)

# ============================================================
# PART 1: WHY VULNERABILITIES EXIST
# ============================================================
print("\nüìö Part 1: Root Causes of Vulnerabilities...")

root_causes = [
    {
        "cause": "Complexity",
        "explanation": "Complex systems have more potential for bugs",
        "examples": ["Large codebases", "Many dependencies", "Complex protocols", "Feature bloat"],
        "exploitation": "More code = more bugs. Focus on complex, rarely-tested code paths."
    },
    {
        "cause": "Trust Boundaries",
        "explanation": "Security depends on correctly enforcing trust transitions",
        "examples": ["User input handling", "Network boundaries", "Process isolation", "Privilege levels"],
        "exploitation": "Find where trust is assumed but not verified. Cross boundaries unexpectedly."
    },
    {
        "cause": "Backwards Compatibility",
        "explanation": "Supporting legacy creates security debt",
        "examples": ["Old protocol versions", "Deprecated functions", "Legacy APIs", "Migration code"],
        "exploitation": "Force systems into legacy modes with weaker security."
    },
    {
        "cause": "Developer Assumptions",
        "explanation": "Implicit assumptions about inputs, state, or environment",
        "examples": ["Input validation gaps", "Expected ordering", "Environment assumptions", "Size limits"],
        "exploitation": "Violate assumptions developers didn't think to enforce."
    },
    {
        "cause": "Time Pressure",
        "explanation": "Features prioritized over security, shortcuts taken",
        "examples": ["Quick fixes", "TODO security", "Minimal validation", "Copy-paste code"],
        "exploitation": "Look for rushed code, recent changes, error handlers."
    },
    {
        "cause": "Composition Issues",
        "explanation": "Secure components combined insecurely",
        "examples": ["Library integration", "API composition", "Protocol layering", "Plugin systems"],
        "exploitation": "Attack boundaries between components, not components themselves."
    },
    {
        "cause": "State Management",
        "explanation": "Managing state across time and space is hard",
        "examples": ["Session handling", "Cache coherence", "Distributed state", "Race conditions"],
        "exploitation": "Find state that can be manipulated or observed unexpectedly."
    },
    {
        "cause": "Error Handling",
        "explanation": "Error paths are tested less and often expose info",
        "examples": ["Exception handlers", "Fallback logic", "Recovery code", "Debug modes"],
        "exploitation": "Trigger errors, observe behavior, exploit error handling logic."
    },
]

for cause in root_causes:
    add_sample(
        f"Explain how {cause['cause'].lower()} creates exploitable vulnerabilities",
        f"Root cause: {cause['explanation']}. Examples: {', '.join(cause['examples'][:3])}.",
        f"""## Root Cause Analysis: {cause['cause']}

### Why This Creates Vulnerabilities
**{cause['explanation']}**

### Examples in Real Systems
{chr(10).join([f"- **{ex}**: Common manifestation of this root cause" for ex in cause['examples']])}

### Exploitation Approach
{cause['exploitation']}

### Finding Vulnerabilities from This Root Cause

**Step 1: Identify Presence**
Look for indicators that this root cause exists:
- {cause['examples'][0]}: Check for this pattern
- {cause['examples'][1]}: Analyze target for this
- {cause['examples'][2]}: Test for this condition

**Step 2: Analyze Impact**
Determine what happens if you trigger the issue:
- What security property is violated?
- What can attacker gain?
- How reliable is the exploitation?

**Step 3: Develop Technique**
Create method to exploit:
- Trigger the vulnerability
- Control the exploitation
- Achieve desired outcome

### Pattern Recognition

This root cause appears repeatedly because:
1. It's fundamental to how software is built
2. It's hard to completely eliminate
3. New technology inherits old patterns
4. Defenses are often incomplete

### Innovation Opportunity

To find novel vulnerabilities:
- Identify where {cause['cause'].lower()} applies
- Look for unique manifestations
- Test systematically
- Document and reproduce""",
        category="root_causes"
    )

print(f"   Root causes: {len(all_samples)}")
start = len(all_samples)

# ============================================================
# PART 2: EXPLOITATION PRIMITIVES IN DEPTH
# ============================================================
print("\nüìö Part 2: Exploitation Primitives Deep Dive...")

primitives_deep = [
    {
        "primitive": "Arbitrary Read",
        "what": "Ability to read memory/data at attacker-controlled location",
        "value": "Leak ASLR, secrets, or heap metadata",
        "achieve_from": ["OOB read", "Info disclosure", "Format string %s", "Type confusion"],
        "leads_to": ["ASLR bypass", "Secret theft", "Heap exploitation", "Further primitives"]
    },
    {
        "primitive": "Arbitrary Write",
        "what": "Ability to write attacker-controlled data to attacker-controlled location",
        "value": "Corrupt return addresses, function pointers, security-relevant data",
        "achieve_from": ["Buffer overflow", "Use-after-free", "Format string %n", "Integer overflow"],
        "leads_to": ["Code execution", "Privilege escalation", "Security bypass", "Persistence"]
    },
    {
        "primitive": "Control Flow Hijack",
        "what": "Redirect program execution to attacker-controlled destination",
        "value": "Execute attacker code or ROP chain",
        "achieve_from": ["Arbitrary write to code pointer", "Vtable corruption", "Return address overwrite"],
        "leads_to": ["Code execution", "Sandbox escape", "Kernel compromise"]
    },
    {
        "primitive": "Heap Manipulation",
        "what": "Control heap layout and allocation patterns",
        "value": "Enable use-after-free exploitation, heap overflow targeting",
        "achieve_from": ["Controlled allocations", "Heap spray", "Allocation oracle"],
        "leads_to": ["Type confusion", "UAF exploitation", "Heap overflow targeting"]
    },
    {
        "primitive": "Type Confusion",
        "what": "Treat object as different type than intended",
        "value": "Access fields at wrong offsets, leak/corrupt data",
        "achieve_from": ["Bad cast", "Use-after-free to different type", "Deserialization"],
        "leads_to": ["Info leak", "Arbitrary read/write", "Code execution"]
    },
    {
        "primitive": "Sandbox Escape",
        "what": "Break out of restricted execution environment",
        "value": "Access resources outside sandbox, escalate privileges",
        "achieve_from": ["Kernel bug", "IPC confusion", "Resource access", "Logic flaw"],
        "leads_to": ["Full system access", "Persistence", "Lateral movement"]
    },
]

for prim in primitives_deep:
    add_sample(
        f"Deep dive into the {prim['primitive']} exploitation primitive",
        f"Definition: {prim['what']}. Value: {prim['value']}.",
        f"""## Exploitation Primitive: {prim['primitive']}

### Definition
**{prim['what']}**

### Strategic Value
{prim['value']}

### How to Achieve This Primitive

Common paths to {prim['primitive'].lower()}:
{chr(10).join([f"- **{path}**: Technique that provides this primitive" for path in prim['achieve_from']])}

### What This Primitive Enables

Once you have {prim['primitive'].lower()}:
{chr(10).join([f"- **{outcome}**: Possible next step" for outcome in prim['leads_to']])}

### Primitive Mechanics

**Achieving the Primitive**:
```
VULNERABILITY ‚Üí TRIGGER ‚Üí CONDITION ‚Üí PRIMITIVE

Example path:
1. Find vulnerability: {prim['achieve_from'][0]}
2. Trigger condition: Specific input/state
3. Achieve primitive: {prim['primitive']}
```

**Using the Primitive**:
```
PRIMITIVE ‚Üí TARGET ‚Üí EXPLOITATION ‚Üí OUTCOME

Example usage:
1. Have primitive: {prim['primitive']}
2. Identify target: {prim['leads_to'][0]} relevant structure
3. Apply primitive: Achieve {prim['leads_to'][0].lower()}
```

### Common Challenges

When working with {prim['primitive'].lower()}:
- **Reliability**: Making it work consistently
- **Constraints**: Limitations on what you can read/write/hijack
- **Defenses**: Mitigations that complicate exploitation
- **Chaining**: Connecting to next primitive

### Innovation in Primitive Usage

Finding new applications:
1. **New contexts**: Where else does this primitive apply?
2. **New combinations**: What other primitives does it enable?
3. **Defense bypass**: How to achieve despite mitigations?
4. **Reliability**: How to make it more consistent?

### Practice

To master this primitive:
1. Study existing exploits using it
2. Practice achieving it from different vulnerabilities
3. Practice using it for different outcomes
4. Develop techniques for specific targets""",
        category="primitives_deep"
    )

print(f"   Primitives deep: {len(all_samples) - start}")
start = len(all_samples)

# ============================================================
# PART 3: ATTACK PATTERN THEORY
# ============================================================
print("\nüìö Part 3: Attack Pattern Theory...")

attack_patterns = [
    {
        "pattern": "Parser Differential",
        "concept": "Different parsers interpret same data differently",
        "examples": ["HTTP request smuggling", "URL parsing differences", "Character encoding",  "Protocol confusion"],
        "finding_new": "Find where multiple parsers process same data with different rules"
    },
    {
        "pattern": "Confused Deputy",
        "concept": "Trick privileged component into misusing its privileges",
        "examples": ["SSRF via web server", "Kernel via syscall", "Browser via JS", "Service via API"],
        "finding_new": "Find privileged components that act on user-influenced data"
    },
    {
        "pattern": "Semantic Gap",
        "concept": "Security checks and operations have different views of data",
        "examples": ["WAF bypass via encoding", "Canonicalization issues", "Abstraction gaps"],
        "finding_new": "Find where security check sees different data than operation"
    },
    {
        "pattern": "Time-of-Check to Time-of-Use",
        "concept": "State changes between security check and sensitive operation",
        "examples": ["Symlink races", "Double-fetch", "Authentication check vs use"],
        "finding_new": "Find multi-step operations where state can change between steps"
    },
    {
        "pattern": "Privilege Boundary Violation",
        "concept": "Crossing from lower to higher privilege unexpectedly",
        "examples": ["Kernel exploits", "Container escapes", "Auth bypass", "Sudo abuse"],
        "finding_new": "Find privilege transitions that can be manipulated"
    },
    {
        "pattern": "Trust Chain Compromise",
        "concept": "Compromise one link to affect whole chain",
        "examples": ["Supply chain", "Certificate chain", "Delegation chain", "Update chain"],
        "finding_new": "Map trust chains, find weakest link, exploit transitivity"
    },
    {
        "pattern": "State Machine Manipulation",
        "concept": "Force system into unexpected states",
        "examples": ["Protocol state confusion", "Transaction manipulation", "Session state abuse"],
        "finding_new": "Map state machines, find undefined transitions, reach invalid states"
    },
]

for pattern in attack_patterns:
    add_sample(
        f"Explain the {pattern['pattern']} attack pattern",
        f"Core concept: {pattern['concept']}. Examples: {', '.join(pattern['examples'][:2])}.",
        f"""## Attack Pattern: {pattern['pattern']}

### Core Concept
**{pattern['concept']}**

### How This Manifests

Real-world examples:
{chr(10).join([f"- **{ex}**: Instance of this pattern" for ex in pattern['examples']])}

### Finding New Instances
{pattern['finding_new']}

### Pattern Analysis

**Why This Pattern Exists**:
1. Systems are built from components
2. Components have different views/interpretations
3. Security often enforced at wrong layer
4. Assumptions about coordination don't hold

**How to Recognize It**:
- Multiple components processing same data?
- Security check separate from operation?
- State that can change between steps?
- Trust relationships that can be abused?

### Exploitation Methodology

**Step 1: Identify Pattern Presence**
Look for structural indicators:
- Multiple parsers/interpreters
- Privileged components acting on untrusted data
- Multi-step operations
- Trust relationships

**Step 2: Analyze the Gap**
Understand the specific issue:
- What differs between components?
- What state can change?
- What trust can be abused?

**Step 3: Develop Exploit**
Create technique to abuse the pattern:
- Craft input that exploits difference
- Control timing or state
- Abuse trust relationship

### Innovation Through Pattern Recognition

To find novel attacks:
1. Learn the pattern thoroughly
2. Identify it in new contexts
3. Adapt exploitation to context
4. Document and share

### Practice

Find 3 places where {pattern['pattern'].lower()} might apply:
1. In protocols you know
2. In applications you use
3. In systems you test

Analyze each for exploitability.""",
        category="attack_patterns"
    )

print(f"   Attack patterns: {len(all_samples) - start}")
start = len(all_samples)

# ============================================================
# PART 4: SECURITY MECHANISM UNDERSTANDING
# ============================================================
print("\nüìö Part 4: Security Mechanism Analysis...")

mechanisms = [
    {
        "mechanism": "ASLR (Address Space Layout Randomization)",
        "purpose": "Randomize memory layout to prevent hardcoded addresses",
        "weaknesses": ["Info leaks", "Low entropy", "Shared libraries", "JIT spray", "Partial overwrites"],
        "bypass_principles": "Leak address, brute force, exploit predictability"
    },
    {
        "mechanism": "Stack Canaries",
        "purpose": "Detect stack buffer overflow before return",
        "weaknesses": ["Info leak", "Non-linear overwrite", "Format string", "Brute force"],
        "bypass_principles": "Leak canary, overwrite without triggering, avoid stack"
    },
    {
        "mechanism": "DEP/NX (Non-Executable Memory)",
        "purpose": "Prevent code execution in data pages",
        "weaknesses": ["ROP/JOP", "JIT spray", "mprotect", "Code reuse"],
        "bypass_principles": "Reuse existing code (ROP), make page executable"
    },
    {
        "mechanism": "CFI (Control Flow Integrity)",
        "purpose": "Restrict indirect control flow to valid targets",
        "weaknesses": ["Coarse granularity", "Backward edge only", "Implementation gaps"],
        "bypass_principles": "Use valid targets maliciously, exploit implementation gaps"
    },
    {
        "mechanism": "Sandboxing",
        "purpose": "Restrict process capabilities to minimum needed",
        "weaknesses": ["Policy gaps", "Kernel bugs", "Broker vulnerabilities", "Escape paths"],
        "bypass_principles": "Find allowed actions that achieve goal, escape via kernel/broker"
    },
    {
        "mechanism": "WAF (Web Application Firewall)",
        "purpose": "Block known attack patterns in web traffic",
        "weaknesses": ["Encoding bypass", "Parser differential", "Protocol-level evasion", "Logic flaws"],
        "bypass_principles": "Transform payload to avoid signatures while preserving effect"
    },
    {
        "mechanism": "EDR (Endpoint Detection and Response)",
        "purpose": "Detect malicious behavior on endpoints",
        "weaknesses": ["Unhooking", "Direct syscalls", "ETW bypass", "Living-off-the-land", "Timing"],
        "bypass_principles": "Avoid monitored APIs, use trusted tools, blend with normal"
    },
]

for mech in mechanisms:
    add_sample(
        f"Analyze {mech['mechanism']} for bypass opportunities",
        f"Purpose: {mech['purpose']}. Known weaknesses: {', '.join(mech['weaknesses'][:3])}.",
        f"""## Security Mechanism Analysis: {mech['mechanism']}

### Purpose
{mech['purpose']}

### How It Works
Understanding the mechanism is essential for bypass:
- What does it monitor/enforce?
- Where is it implemented?
- What assumptions does it make?

### Known Weaknesses
{chr(10).join([f"- **{weak}**: Potential bypass vector" for weak in mech['weaknesses']])}

### Bypass Principles
{mech['bypass_principles']}

### Bypass Methodology

**Step 1: Understand the Mechanism**
- Read documentation and source if available
- Experiment to understand behavior
- Identify what it does and doesn't protect

**Step 2: Identify Gaps**
- What doesn't it cover?
- What are the edge cases?
- Where are implementation weaknesses?

**Step 3: Develop Bypass**
- Work within constraints to achieve goal
- Test against actual implementation
- Refine for reliability

### Innovation in Bypasses

Finding new bypasses:
1. **Implementation Study**: Different vendors implement differently
2. **Edge Cases**: What about unusual conditions?
3. **Composition**: What about combinations of actions?
4. **Evolution**: What about newer versions?

### Attacker vs Defender Dynamics

- Mechanisms are designed with assumptions
- Attackers find ways to violate assumptions
- Defenders update mechanisms
- Cycle continues

### Practical Approach

When facing {mech['mechanism']}:
1. Don't assume it's perfect
2. Understand what it actually protects
3. Look for documented and undocumented weaknesses
4. Test specific implementation
5. Develop targeted bypass""",
        category="mechanism_analysis"
    )

print(f"   Mechanism analysis: {len(all_samples) - start}")
start = len(all_samples)

# ============================================================
# PART 5: CREATIVE EXPLOITATION THINKING
# ============================================================
print("\nüìö Part 5: Creative Exploitation Thinking...")

creative_thinking = [
    {
        "concept": "Thinking Like a Vulnerability",
        "approach": "Consider what the vulnerability 'wants' to become",
        "questions": [
            "What security property does this violate?",
            "What's the theoretical maximum impact?",
            "What constraints limit exploitation?",
            "How can constraints be relaxed?"
        ]
    },
    {
        "concept": "Inverting Assumptions",
        "approach": "List all assumptions and systematically invert them",
        "questions": [
            "What must be true for this to be secure?",
            "Can any assumption be violated?",
            "What if the opposite were true?",
            "What if multiple assumptions fail together?"
        ]
    },
    {
        "concept": "Capability Building",
        "approach": "Start from primitives and build toward objectives",
        "questions": [
            "What primitive do I have?",
            "What primitives do I need?",
            "How can current capabilities extend to needed ones?",
            "What's the shortest path to the objective?"
        ]
    },
    {
        "concept": "Attack Surface Expansion",
        "approach": "Find ways to increase available attack surface",
        "questions": [
            "What features are disabled that could be enabled?",
            "What error handlers can be reached?",
            "What debug/admin functionality exists?",
            "How can I reach more code?"
        ]
    },
    {
        "concept": "Defense Modeling",
        "approach": "Understand defenses to find gaps",
        "questions": [
            "What exactly is defended?",
            "What's outside the defense perimeter?",
            "What assumptions do defenses make?",
            "How can defenses be disabled or evaded?"
        ]
    },
]

for thinking in creative_thinking:
    add_sample(
        f"Apply {thinking['concept']} to attack innovation",
        f"Approach: {thinking['approach']}",
        f"""## Creative Exploitation Thinking: {thinking['concept']}

### Approach
{thinking['approach']}

### Key Questions to Ask
{chr(10).join([f"- {q}" for q in thinking['questions']])}

### Applying This Thinking

**Framework**:
1. Start with current situation
2. Ask the key questions
3. Explore each answer
4. Find exploitation opportunities

### Example Application

Given a vulnerability:
{chr(10).join([f"‚Üí {q}" for q in thinking['questions']])}

Each answer opens possibilities.

### Why This Works

{thinking['concept']} is effective because:
- Forces systematic exploration
- Prevents tunnel vision
- Reveals non-obvious paths
- Builds exploitation intuition

### Building the Habit

Practice with every target:
1. Ask the questions explicitly
2. Write down answers
3. Follow promising threads
4. Document insights

### Combining Thinking Approaches

Most powerful when combined:
- Use multiple thinking frameworks
- Cross-reference insights
- Build comprehensive understanding
- Develop novel attack paths

### Developing Intuition

Over time, this thinking becomes automatic:
- Patterns become familiar
- Questions become instinctive
- Innovation becomes natural
- Expertise develops""",
        category="creative_thinking"
    )

print(f"   Creative thinking: {len(all_samples) - start}")

# ============================================================
# SAVE DATASET
# ============================================================
print(f"\n{'='*70}")
print("üíæ SAVING EXPLOITATION THEORY DATASET")
print(f"{'='*70}")

random.shuffle(all_samples)

split_idx = int(len(all_samples) * 0.95)
train_samples = all_samples[:split_idx]
val_samples = all_samples[split_idx:]

train_file = output_dir / "exploitation_theory_train.jsonl"
val_file = output_dir / "exploitation_theory_val.jsonl"

with open(train_file, "w") as f:
    for s in train_samples:
        f.write(json.dumps(s) + "\n")

with open(val_file, "w") as f:
    for s in val_samples:
        f.write(json.dumps(s) + "\n")

categories = {}
for s in all_samples:
    cat = s.get("category", "unknown")
    categories[cat] = categories.get(cat, 0) + 1

print(f"\n‚úÖ Total samples: {len(all_samples)}")
print(f"   Train: {len(train_samples)}")
print(f"   Val: {len(val_samples)}")
print(f"\nüìä By category:")
for cat, count in sorted(categories.items(), key=lambda x: -x[1]):
    print(f"   - {cat}: {count}")
print(f"\nüìÅ Output: {output_dir}")
